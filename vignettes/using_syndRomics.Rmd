---
title: "Using syndRomics"
author: "Abel Torres Espin"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Using syndRomics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

**The package is in development, please contact Abel Torres Espin (abel.torresespin@UCSF or atpspin@gmail.com) if you find errors or have ideas about improving the package**

# The syndRomics package

In this document we will see examples of using the **syndRomics** package for helping in the process of disease patterns analysis by means of principal components. The package implements functions for component visualization, interpretation and stability analysis. For details on the analysis, please see the manuscript:

    Abel Torres-Espin, Austin Chou, J. Russell Huie, Nikos Kyritsis, Pavan Upadhyayula, and Adam R. Ferguson. Reproducible analysis of disease space via principal components: a brief tutorial and R package (syndRomics). 


The goal of the analysis is to understand complex disease states or patterns as common factors (syndromes) that can be quantified from measured variables through the use of computational and analytic approaches (Ferguson et al., 2011, Torres-Espin et al., 2020). In particular, principal component analysis (PCA) and related multivariate statistics has been used as primary toolkit for extracting disease patterns. The **syndRomics** package contain utility functions for aiding in the process of component interpretation, visualization and stability analysis by means of the principal component.

Here you will find the basics of the package. There is more than what is shown in this vignette, so we encorage you to explore further.

# Setting up

For this example we will use a public dataset accessible through the Open Data Commons for Spinal Cord Injury [ODC-SCI:26](DOI:10.7295/W9T72FMZ). The dataset consist on studies of subjects with cervical spinal cord injury and a battery of functional test to assess neurological function after injury. For the example we will be using the data at 6 weeks after injury.

The same data have been used in the past by Adam Ferguson team to perform SCI syndromics analysis:

    Ferguson AR, Irvine K-A, Gensel JC, Nielson JL, Lin A, Ly J, et al. Derivation of Multivariate Syndromic Outcome Metrics for Consistent Testing across Multiple Models of Cervical Spinal Cord Injury in Rats. PLOS ONE. 2013 Mar 27;8(3):e59712.

We will use the following libraries:
```{r}
library(syndRomics)
library(ggplot2)
library(dplyr)
library(stringr)
library(progress)
```

Loading the data and extracting the variables at 6 weeks after injury. To simplify
the analysis for this example, a list-wise deletion has been performed to deal with missing values. For an example of combining syndRomics with multiple imputation strategies see the paper.

```{r, fig.width=6, fig.height=5}
odc.df<-read.csv('odc-sci_26.csv', na.strings = '')
odc.df.filter<-odc.df[-1,str_detect(colnames(odc.df),"_wk6")]
odc.df.filter<-odc.df.filter[complete.cases(odc.df.filter),] #delete missing
colnames(odc.df.filter)<-str_remove(colnames(odc.df.filter), "_wk6")
colnames(odc.df.filter)<-str_remove(colnames(odc.df.filter), "AbsDev")#shorten var names

odc.df.filter[1:10,1:6]
```

# PCA

All functions in the package with the *pca* argument would accept the results of running either *prcomp()* for linear PCA, or *Gifi::princals()* for non-linear PCA.

Here we illustrate the package using *prcomp()*. We first perform PCA on the data and calculate the standardized loadings.
```{r}
pca_data<-as.matrix(apply(odc.df.filter, 2, as.numeric))
pca<-prcomp(pca_data, center = T, scale. = T)
```

We can extract the standardized loadings with a helper function:

```{r}
original_loadings<-syndRomics:::stand_loadings(pca, pca_data)
original_loadings[1:10,1:5]
```


# How many components to keep?

The first question to respond after a PCA solution has been found is usually about knowing how many PCs are relevant. The goal is to determine the minimal set of components that can be used to describe the disease space. 

The syndRomics package implements a nonparametric permutation test for the variance accounted for (VAF), previously suggested as a hypothesis test of whether a PC is generated at random or not. We can generate the null distribution for such test by means of permutation, which breaks the structure of the data. Note that there are several other methods broadly used to decide the "importance" of components. The number of permutations (P) affects the results and it should be chosen to be big enough. To make this vignette fast to build, we used P=100, but you probably want to use at least 500.

```{r}
set.seed(500)
per<-permut_pc_test(pca, pca_data, P=100, ndim=5)
per$results
```

We can see that the three first components are statistically significant by the permutation test.

We plot the original VAF vs. the permuted VAF
```{r, fig.width=4, fig.height=4}
per$per_plot
```

# Component Interpretation (identity)

**permut_pc_test()**

The next step in the analysis is to interpret the meaning of the components. That is, providing the PCs with a "identity". This is done by looking at metrics that measure the impact of PCs into variables. The syndRomic package works with standardized loadings and communalities. Standardized loadings are interpreted as the correlation coefficient between a PC and a variable, indicative of the contribution of variables in magnitude and direction of each PC. Communalities are the sum of squared loadings for each variable for the PCs retained during component selection, and they represent how much of the variance of each variable can be explained by the total number of kept components. These can be interpreted as the impact of a variable in the chosen PCA solution formed by the retained PCs. 

To decide PC identity, usually only the higher loadings are used. The cut-off to determine if a loading is "important" or high enough in the interpretation of a PC can be decided in several ways. Using the knowledge of the researcher, several authors suggested rules of thumb for such threshold. Others have suggested a more analytic approach. The syndRomic package implements a non-parametric permutation test for loadings as previously suggested (Buja and Eyuboglu, 1992; Linting et al., 2011).

```{r}
s_per<-permut_pc_test(pca, pca_data, P=100, ndim=3, statistic = 's.loadings', perm.method = 'permV')
s_per$results$PC1
s_per$results$PC2
s_per$results$PC3
```

We can see that the cut-off of significance (for alpha =0.05) using the adjusted p value is around |0.25| for PC1, around |0.3| for PC2 and around |0.45| for PC3 based on the permutation test.

We can get a barmap plot of the loadings and the permuted distribution (dot and error bars represents mean +/- 95%CI of permuted samples)

```{r, fig.width=8}
s_per$per_plot
```

Same analysis can be performed for communalities. See *?permut_pc_test* for details

# Component stability

**pc_stability()**

Component stability refers to the sensitivity of the PCs to variation, and it is important to study to understand the robustness of the analysis. The package implements functions to help in the process of studying the component stability to data selection variability using resampling methods such as bootstrapping. A robust PC would have small sensitivity to data variations, and thus the goal of the stability analysis is to determine such sensitivity. The package uses nonparametric bootstrapping as previously described for component stability (Babamoradi et al., 2013; Linting et al., 2007; Timmerman et al., 2007; Zientek & Thompson, 2007).

## Stability measures

Component stability can be measured at the component level or at the level of loadings or communalities. At the component level, the package includes: Congruence coefficient, Pearson's r, root mean square error (RMSE) and Cattell's s index (see *?component_similarity for details*). At the level of loadings and communalities, the package allows for computing nonparametric confident intervals. A narrow confident region means that the loading or communality is stable to resampling variations. The *pc_stability()* function returns the accelerated and bias-corrected 95% confident interval for the loadings by default as it has been shown to be robust in different simulation conditions (Efron, B. 1987). For the similarity metrics, the confident interval by the percentile method is returned.

Setting the argument *barmap_plot* = TRUE will create a barmap plot with the average and the confident interval of the bootstrapped loadings and communalities.

See *?pc_stability* for more options.

```{r}
booted_PCA<-pc_stability(pca, pca_data,ndim = 3,B =200, test_similarity = T, similarity_metric = "all")
booted_PCA$results
```

**Component similarity**
```{r}
booted_PCA$PC_similarity
```

**Plotting loadings and CI**
```{r fig.width=7, fig.height=5}
booted_PCA$boot_barmap_loadings
```

**Plotting communalities and CI**
```{r fig.width=7, fig.height=5}
booted_PCA$boot_barmap_communalities
```

# Let's get visual

Visualizations might aid in the process of component interpretation. The syndRomics package implements 3 different visualizations for the standardized loadings: syndromic plots, heatmap of loadings and barmap of loadings or communalities.

Any of these visualization can be obtained from either the results of the *prcomp()* or *princals()* functions, or a data.frame containing the loadings. That allows for generating the plots from loadings obtained by any other function/package/software. In the case of pass a data.frame to the plotting functions, the structure should be as follow: 

    First column named "Variables" and a column for each PCs. One row per variable. The values are the loadings.

In case a data.frame of loadings is passed to the plotting functions, the VAF argument must be given as a character vector of the same lenght of the PCs to plot (ndim) and format: c("60.1%","20.2%") for example. If the results of *prcomp()* or *princals()* are passed, VAF is internally calculated.

## Syndromic plots

The syndromic plot were designed and first published by Ferguson et al, 2013. The plot consist on a middle convex triangle (the intersection of a Venn diagram with 3 sets) displaying the variance accounted for (VAF) for a PC and arrows pointing to the center of the triangle representing each variable. The width of each arrow and the color are proportional to the standardized loading they represent. The variables to plot are determined by a threshold of “importance” for the loadings. Syndromic plots are especially useful to report PC identity in publication.

```{r fig.height=9, fig.width=9}
splot<-syndRomics::syndromic_plot(pca, pca_data, cutoff = 0.45, text_size = 7)
splot$PC1
splot$PC2
splot$PC3
```

The *syndromic_plot()* function returns a ggplot2 object that can be further tuned using the ggplot2 package. You will notice that the arrows do not look quite right in Windows machines. This is a problem with the plotting device. Saving the plot to pdf makes it nicer and it can be easily changes in case need further tuning for publication.

```{r out.width=500, out.height=500}
ggsave(plot = splot$PC1, filename = 'PC1.pdf', width = 9, height = 9)
knitr::include_graphics("PC1.pdf")
```

## Heatmap and Barmap plots

Heatmap and barmap plots are other visualizations of the loadings (and communalities in case of barmaps) offering other options beyond the syndromic plot, also returning ggplot2 objects. The major difference between these two plots and the syndromic plot is that both heatmap and barmap plots display all variables (although a subset can be specified using the *vars* argument). This is particularly useful when there are too many variables to plot that might make syndromic plots too crowded, or to compare loadings between PCs more easily. These plots are implemented in the *heatmap_loading()*, the *barmap_loading()*, and the *barmap_commun()* functions. 

```{r fig.width=5, fig.height=4}
h_plot<-heatmap_loading(pca, pca_data, ndim=3, cutoff = 0.45, star_values = T, text_values = F)
h_plot
#The plot can be saved as any other ggplot2 object
#ggsave(plot=h_plot, file="h_plot.png") 
```

```{r fig.width=8, fig.height=4}
b_plot<-barmap_loading(pca, pca_data, ndim=3, cutoff = 0.45)
b_plot

#The plot can be saved as any other ggplot2 object
#ggsave(plot=b_plot, file="b_plot.png") 
```

## Tunning up the plots

The plots generated by the **syndRomics** package are ggplot2 objects that can be further modified using the ggplot2 package. For instance, we can play around with the legend:

```{r fig.width=8, fig.height=4}
b_plot+theme(legend.position = 'bottom', legend.key.width = unit(15,'mm'),
           legend.key.height = unit(2,'mm'),legend.justification = 'left',
           legend.title = element_text(vjust = 1.3),panel.spacing = unit(5,'mm'))
```

Other tunning parameters are offered by the visualization function on the **syndRomics** package.

**Titles.** For heatmap and barmap plots, the *plot_title* and the *legend_title* can be pass to the functions.
```{r fig.width=6}
barmap_loading(pca, pca_data, ndim=3, cutoff = 0.45, plot_title = 'Loadings', legend_title = 'Loadings')
```

**Values.** Whether to plot the value of the loadings or a star indicating the |loadings| >= cutoff can be controled by the *star_value* and the *text_value* arguments.
```{r fig.width=5, fig.height=4}
heatmap_loading(pca, pca_data, ndim=3, cutoff = 0.45, star_values = F,text_values = T)
```

**Text size.** The text size in the plot can be set using the *text_size* argument

**Variable order.** The order of the variables in the syndromic plot can be set by the *var_order* argument. These can be set as "abs decreasing" (absolute decreeing), "abs increasing" (absolute increasing), "decreasing" or "increasing".

```{r fig.height=7, fig.width=7}
syndromic_plot(pca, pca_data, ndim=1, cutoff = 0.45, text_size = 5, var_order = 'abs increasing')
syndromic_plot(pca, pca_data, ndim=1, cutoff = 0.45, text_size = 5, var_order = 'decreasing')
```


# More information

You can read more about the specific functions using the *help()* or *?*. A more detailed explanation of the implementation can be find in the paper.

    Abel Torres-Espin, Austin Chou, J. Russell Huie, Nikos Kyritsis, Pavan Upadhyayula, and Adam R. Ferguson. Reproducible analysis of disease space via principal components: a brief tutorial and R package (syndRomics).

# References

* Ferguson AR, Stück ED, Nielson JL. Syndromics: A Bioinformatics Approach for Neurotrauma Research. Transl Stroke Res. 2011 Dec;2(4):438–54.

* Buja A, Eyuboglu N. Remarks on Parallel Analysis. Multivar Behav Res. 1992 Oct 1;27(4):509–40

* Linting M, van Os BJ, Meulman JJ. Statistical Significance of the Contribution of Variables to the PCA solution: An Alternative Permutation Strategy. Psychometrika. 2011 Jul 1;76(3):440–60

* Linting M, Meulman JJ, Groenen PJF, van der Kooij AJ. Stability of nonlinear principal components analysis: An empirical study using the balanced bootstrap. Psychol Methods. 2007;12(3):359–79. 

*	Babamoradi H, van den Berg F, Rinnan Å. Bootstrap based confidence limits in principal component analysis — A case study. Chemom Intell Lab Syst. 2013 Jan 15;120:97–105. 

*	Timmerman ME, Kiers HAL, Smilde AK. Estimating confidence intervals for principal component loadings: a comparison between the bootstrap and asymptotic results. Br J Math Stat Psychol. 2007 Nov;60(Pt 2):295–314. 

*	Zientek LR, Thompson B. Applying the bootstrap to the multivariate case: Bootstrap component/factor analysis. Behav Res Methods. 2007 May;39(2):318–25.

*   Efron, B. (1987). Better Bootstrap Confidence Intervals. Journal of the American Statistical Association, 82(397), 171–185. https://doi.org/10.1080/01621459.1987.10478410
  
* Ferguson AR, Irvine K-A, Gensel JC, Nielson JL, Lin A, Ly J, et al. Derivation of Multivariate Syndromic Outcome Metrics for Consistent Testing across Multiple Models of Cervical Spinal Cord Injury in Rats. PLOS ONE. 2013 Mar 27;8(3):e59712.

# Session information
```{r}
sessionInfo()
```

